<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Scene with LoveWare Text</title>
    <style>
        html, body {
            margin: 0;
            height: 100%;
            overflow: hidden;
        }
        lume-element3d {
            display: block;
            width: 100%;
            height: 100%;
        }
        #loveWareText {
            color: white;
            font-size: 50px;
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            visibility: hidden; /* Initially hidden */
        }
    </style>
</head>
<body>
    <lume-scene webgl id="scene" background-color="black" background-opacity="1">
        <!-- eclipsed sun -->
        <lume-sphere has="basic-material" color="orange" size="300 300 300" mount-point="0.5 0.5 0.5">
            <lume-camera-rig
                id="rig"
                horizontal-angle="-69"
                min-vertical-angle="0"
                max-vertical-angle="0"
                align-point="0.5 0.5 0.5"
            >
                <!-- eclipsing planet -->
                <lume-sphere
                    has="basic-material"
                    color="black"
                    size="242 242 242"
                    mount-point="0.5 0.5 0.5"
                    position="363 0 0"
                    slot="camera"
                ></lume-sphere>
            </lume-camera-rig>
        </lume-sphere>

        <lume-perspective-camera position="0 0 2000" active near="500" far="8000"></lume-perspective-camera>

        <!-- Stars -->
        <lume-sphere
            id="stars"
            texture="../../examples/hello-world/galaxy_starfield.png"
            receive-shadow="false"
            has="basic-material"
            sidedness="back"
            size="6000 6000 6000"
            mount-point="0.5 0.5 0.5"
            color="white"
        ></lume-sphere>
    </lume-scene>

    <div id="loveWareText">LoveWare</div>

    <script src="../../importmap.js"></script>
    <script type="x-shader/x-vertex" id="vertexshader">
        varying vec2 vUv;

        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform sampler2D baseTexture;
        uniform sampler2D bloomTexture;
        varying vec2 vUv;

        void main() {
            gl_FragColor = (texture2D(baseTexture, vUv) + vec4(1.0) * texture2D(bloomTexture, vUv));
        }
    </script>

    <script type="module">
        import {Motor} from 'lume';
        import {ReinhardToneMapping, Vector2, ShaderMaterial} from 'three';
        import {EffectComposer} from 'three/addons/postprocessing/EffectComposer.js';
        import {RenderPass} from 'three/addons/postprocessing/RenderPass.js';
        import {ShaderPass} from 'three/addons/postprocessing/ShaderPass.js';
        import {UnrealBloomPass} from 'three/addons/postprocessing/UnrealBloomPass.js';
        import {OutputPass} from 'three/addons/postprocessing/OutputPass.js';

        scene.glRenderer.toneMapping = ReinhardToneMapping;

        const bloomComposer = new EffectComposer(scene.glRenderer);
        bloomComposer.renderToScreen = false;

        const finalComposer = new EffectComposer(scene.glRenderer);

        const renderPass = new RenderPass(scene.three, scene.threeCamera);
        finalComposer.addPass(renderPass);
        bloomComposer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
            new Vector2(scene.clientWidth, scene.clientHeight)
        );
        bloomPass.threshold = 0;
        bloomPass.strength = 1;
        bloomPass.radius = 0.5;
        bloomComposer.addPass(bloomPass);

        const mixPass = new ShaderPass(
            new ShaderMaterial({
                uniforms: {
                    baseTexture: {value: null},
                    bloomTexture: {value: bloomComposer.renderTarget2.texture},
                },
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                defines: {},
            }),
            'baseTexture'
        );
        mixPass.needsSwap = true;
        finalComposer.addPass(mixPass);

        const outputPass = new OutputPass();
        finalComposer.addPass(outputPass);

        function handleSizing() {
            finalComposer.setPixelRatio(window.devicePixelRatio);
            bloomComposer.setPixelRatio(window.devicePixelRatio);
            const resize = () => {
                finalComposer.setSize(scene.clientWidth, scene.clientHeight);
                bloomComposer.setSize(scene.clientWidth, scene.clientHeight);
            }
            const observer = new ResizeObserver(resize);
            observer.observe(scene);
        }

        handleSizing();

        scene.drawScene = () => {
            renderPass.camera = scene.threeCamera;

            stars.three.material.color.set('black');
            bloomComposer.render();

            stars.three.material.color.set('white');
            finalComposer.render();
        }

        const autoRotate = true;

        if (autoRotate) {
            rig.rotation = (x, y, z) => [x, y - 0.03, z];
        } else {
            setTimeout(() => scene.needsUpdate(), 100);
        }

        function updateTextVisibility() {
            const moon = scene.querySelector('lume-sphere[slot="camera"]');
            const loveWareText = document.getElementById('loveWareText');

            if (moon && loveWareText) {
                const moonPosition = moon.position;
                // Check if the moon is centered (adjust the range as needed)
                if (Math.abs(moonPosition.x) < 10 && Math.abs(moonPosition.y) < 10 && Math.abs(moonPosition.z) < 10) {
                    loveWareText.style.visibility = 'visible';
                } else {
                    loveWareText.style.visibility = 'hidden';
                }
            }
        }

        // Call the function to update text visibility
        updateTextVisibility();
    </script>
</body>
</html>
